<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Sneaking a peek at Daimio</title>
	
	<meta name="description" content="A language for sharing">
	<meta name="author" content="dann toliver">
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="core/deck.core.css">
  <!-- <link rel="stylesheet" href="../extensions/goto/deck.goto.css">
  <link rel="stylesheet" href="../extensions/menu/deck.menu.css">
  <link rel="stylesheet" href="../extensions/hash/deck.hash.css">
  <link rel="stylesheet" href="../extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" href="../extensions/status/deck.status.css">
  <link rel="stylesheet" href="../extensions/scale/deck.scale.css"> -->

	
	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="themes/style/swiss.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="themes/transition/horizontal-slide.css">
	
	<script src="modernizr.custom.js"></script>
</head>

<body class="deck-container">

<!-- Begin slides -->
<section class="slide" id="title-slide">
  <h1>
    <span style="font-size:0.4em">Sneaking a peek at</span>
    <p>Daimio</p>
    <span style="font-size:0.2em">A conversation in three acts</span>
  </h1>
</section>

<section class="slide" id="motivation">
  <h1>
    Act I
    <p style="font-size:0.4em">Motivation</p>
  </h1>
</section>

<section class="slide" id="paper-is-great">
  <h2>Paper is great</h2>
  
  <img src="../application.jpg"></img>
</section>

<section class="slide" id="paper-is-awful">
  <h2>Paper is awful</h2>
  
  <ul>
    <li>The data is analog</li>
    <li>And isn't on the network</li>
    <li>Immutable, but not in a good way</li>
  </ul>
</section>

<section class="slide" id="web-is-awful">
  <h2>The web is awful too</h2>
  
  <ul>
    <li>Cumbersome workflows</li>
    <li>Fixed interfaces</li>
    <li>Frozen functionality</li>
    <li>Can't be extended or modified</li>
  </ul>
</section>

<section class="slide" id="web-is-great">
  <h2>The web is great</h2>
  
  <ul>
    <li>Everything is everywhere</li>
    <li>Interconnected applications</li>
    <li>External computing resources</li>
    <li>Nearly native speeds</li>
  </ul>
</section>

<section class="slide" id="web-is-useful">
  <h2>I want to use the web for everything</h2>
  
  <ul>
    <li>The browser is the operating system</li>
    <li>This tab is an application</li>
    <li>Visiting a URL is software installation</li>
  </ul>
</section>

<section class="slide" id="web-is-sadface">
  <h2>But alas</h2>
  
  <ul>
    <li>I can't modify those applications</li>
    <li>I can't control my experience</li>
    <li>I can't connect them together</li>
  </ul>
</section>

<section class="slide" id="monkeys-are-always-the-answer">
  <h2>Greasemonkey?</h2>
  
  <ul>
    <li>I can modify and extend the application...</li>
    <li class="slide">But at what cost?</li>
    <li class="slide">No safety, no limits, no programmability exposed</li>
    <li class="slide">No connection to the app</li>
    <li class="slide">No community in the app.</li>
  </ul>
</section>

<section class="slide" id="progweb">
  <h2>Make the web programmable!</h2>
  
  <p>Way beyond just APIs</p>

  <ul>
    <li>Crowd-sourced interfaces</li>
    <li>Enhanced functionality</li>
    <li>Marketplace for innovation</li>
  </ul>
</section>

<section class="slide" id="use-cases">
	<h2>Who benefits?</h2>
	<ul>
		<li class="slide">Corporate tools</li>
		<li class="slide">Enterprise-focused services</li>
    <li class="slide">Tool-based services</li>
    <li class="slide">Web communities</li>
    <li class="slide">Web-based games</li>
	</ul>
</section>

<section class="slide" id="if-youre-having-web-problems">
  <h2>Problems with corporate tools</h2>
  
  <ul>
    <li>Unforeseen uses</li>
    <li>Inefficient pathways</li>
    <li>Different strokes</li>
    <li>Enhancement requests</li>
    <li>Bug fixes</li>
  </ul>
</section>

<section class="slide" id="gamesyousay">
  <h2>You said something about games...</h2>
  
  <ul>
    <li>Programmable world</li>
    <li>Humans vs bots (free AI)</li>
    <li>Client-based MMO</li>
  </ul>
</section>

<section class="slide" id="needs">
	<h2>We need the power to:</h2>
	<ul>
		<li class="slide">
			Craft interfaces
		</li>
    <li class="slide">
      Add functionality to them
    </li>
    <li class="slide">
      Modify that functionality
    </li>
    <li class="slide">
      Share modified functionality with others
    </li>
    <li class="slide">
      Run modified functionality on server.
    </li>
	</ul>
</section>


<section class="slide" id="daimio">
  <h1>
    Act II
    <p style="font-size:0.5em">Daimio</p>
  </h1>
</section>

<section class="slide" id="is-a-lang">
  <h2>Daimio is a language</h2>
  <ul>
		<li class="slide">
      "Types": numbers, strings, lists, commands:
      <pre><code>{ ( 123 "foo" (1 2 3) ) }</code></pre>
    </li>
		<li class="slide">
      Commands have named params:
      <pre><code>{math add value 3.14 to 2}</code></pre>
    </li>
		<li class="slide">
      Lists can be keyed:
      <pre><code>{* (:x 5 :y -12) }</code></pre>
    </li>
  </ul>
</section>

<section class="slide" id="is-a-dataflow">
  <h2>Daimio is a dataflow language</h2>
  <pre><code>
    {41 | add 1}
    {(1 2 3) | add}
    {(1 2 3) | add 1}
    {(1 2 3) | add (3 2 1)}
  </code></pre>
    
  <pre class="slide"><code>
    {(1 2 3) | map block "{__ | add 5 | mod 7}"}
  </code></pre>
</section>

<section class="slide" id="for-sharing">
  <h2>Daimio is a language for sharing</h2>
  <ul>
		<li>
      Commands are permissible
    </li>
		<li class="slide">
      Dialects contain commands
    </li>
		<li class="slide">
      Execution context has a dialect.
    </li>
  </ul>
</section>

<section class="slide" id="is-extensible">
  <h2>Daimio is extensible</h2>
  <ul>
    <li>
      You publish commands to create your application's functionality
    </li>
    <li class="slide">
      Create specialized dialects within your app.
    </li>
  </ul>
</section>

<section class="slide" id="is-universal">
  <h2>Daimio is a universal language</h2>
  <ul>
    <li>
      Used by ops, devs, designers, marketeering, business folk and end users
    </li>
    <li class="slide">
      The command list is your API 
    </li>
    <li class="slide">
      Design your API first, enjoy concurrent development.
    </li>
  </ul>
</section>

<section class="slide" id="not-gp">
  <h2>Daimio is not general purpose</h2>
  <ul>
		<li>
      Domain specific, for your specific domain
    </li>
		<li class="slide">
      A gift you give your users
    </li>
		<li class="slide">
      Control over the parts that matter
    </li>
		<li class="slide">
      Performance issues? Add a new command (i.e. do it in JS)
    </li>
		<li class="slide">
      Unwieldy? Add a new command.
    </li>
  </ul>
</section>

<section class="slide" id="is-a-vm">
  <h2>Daimio is a virtual machine</h2>
  <ul>
    <li>
      Segments is an array of numbers, strings, "lists", and commands
    </li>
    <li class="slide">
      Wiring is a set of directed edges between segments
    </li>
    <li class="slide">
      Wiring forms a DAG
    </li>
    <li class="slide">
      Lists and commands are exploded
    </li>
    <li class="slide">
      {segments: ___, wiring: ___} is expressible in JSON.
    </li>
  </ul>
</section>

<section class="slide" id="is-a-jit">
  <h2>VM benefit: JIT</h2>
  <ul>
    <li>
      Deoptimized to build VM (~4x)
    </li>
    <li class="slide">
      Simplicity trumps performance
    </li>
    <li class="slide">
      Orthogonal optimization.
    </li>
  </ul>
</section>

<section class="slide" id="is-an-async">
  <h2>VM benefit: Async</h2>
  <ul>
    <li>
      We want JS async to be sync in Daimio
    </li>
    <li class="slide">
      Don't split functions 
    </li>
    <li class="slide">
      Don't invert control
    </li>
    <li class="slide">
      VM handles async and continues where it left off.
    </li>
  </ul>
</section>

<section class="slide" id="is-a-dataflow">
  <h2>Daimio is a framework</h2>
  <ul>
    <li>
      A space is an execution context: a dialect and state
    </li>
    <li class="slide">
      Spaces send and receive messages via ports 
    </li>
    <li class="slide">
      A space can contain subspaces, which inherit its dialect
    </li>
    <li class="slide">
      A space can contain code blocks, each wrapped in a station
    </li>
    <li class="slide">
      Stations have ports too.
    </li>
  </ul>
</section>

<section class="slide" id="is-projectional">
  <h2>Daimio is projectional</h2>
  <ul>
    <li>
      Code is not the final artifact; VM data structure is
    </li>
    <li class="slide">
      VM data can be projected back into code form
    </li>
    <li class="slide">
      Could be projected into other forms too
    </li>
    <li class="slide">
      All projected representations are equivalent
    </li>
    <li class="slide">
      (Though not all are first class)
    </li>
    <li class="slide">
      There's more than one way to view it.
    </li>
  </ul>
</section>

<section class="slide" id="is-projectional">
  <h2>Spaces are data too</h2>
  <ul>
    <li>
      JSON-representable data structure, like Daimio code
    </li>
    <li class="slide">
      Like Daimio code, representable in multiple ways 
    </li>
    <li class="slide">
      Immutable and uniquely id'd regardless of manufacturer.
    </li>
  </ul>
</section>

<section class="slide" id="is-immutable">
  <h2>Spaces are immutable</h2>
  <ul>
    <li>
      Routes are defined at compile time (like FBP)
    </li>
    <li class="slide">
      No one knows what's outside
    </li>
    <li class="slide">
      A component with a given ID will *always* behave the same
    </li>
    <li class="slide">
      Requires propagating changes upward on edit.
    </li>
  </ul>
</section>

<section class="slide" id="has-diish">
  <h2>Daimio has DI (ish)</h2>
  <ul>
    <li class="slide">
      Inside a space, the outer world is only seen through arriving messages
    </li>
    <li class="slide">
      Spaces attach to the outside through ports
    </li>
    <li class="slide">
      Database access is handled through "synchronized asynchronous" ports (send-and-receive)
    </li>
    <li class="slide">
      Likewise for random numbers, current date, anything impure
    </li>
    <li class="slide">
      Implicit port creation and routing
    </li>
    <li class="slide">
      Benefits of dependency injection vis-a-vis testing.
    </li>
  </ul>
</section>

<section class="slide" id="is-pureish">
  <h2>Daimio is pure (ish)</h2>
  <ul>
    <li class="slide">
      Memoizable over ship + state
    </li>
    <li class="slide">
      Event reply w+/-o side effects
    </li>
    <li class="slide">
      Process 0, 1, or N times
    </li>
    <li class="slide">
      Optimistic concurrency control (STM).
    </li>
  </ul>
</section>

<section class="slide" id="has-types">
  <h2>Daimio has "types"</h2>
  <ul>
    <li class="slide">
      Types for data: numbers, strings, lists
    </li>
    <li class="slide">
      Types for params: integers, blocks, tree, [number], number|[number]
    </li>
    <li class="slide">
      Flavours for ports: db, dom, network, audio, svg
    </li>
    <li class="slide">
      Typehints for ports too (implicit).
    </li>
  </ul>
</section>

<section class="slide" id="pause-here">
  <h2>Remember to pause for button demos...</h2>
</section>







<section class="slide" id="techniques">
  <h1>
    Act III
    <p style="font-size:0.4em">Techniques</p>
  </h1>
</section>

<section class="slide" id="were-doing-it">
  <h2>We're doing this now</h2>
  <ul>
    <li>
      Six years of stable development 
    </li>
    <li class="slide">
      Puts power where it belongs
    </li>
    <li class="slide">
      Minimizes dev/design turn around
    </li>
    <li class="slide">
      Unit tests == integration tests
    </li>
    <li class="slide">
      Often trivial to add new features.
    </li>
  </ul>
</section>

<section class="slide" id="howie-do-it">
  <h2>How we do it</h2>
  <ul>
    <li>
      Determine commands (shared language)
    </li>
    <li class="slide">
      Views are just Daimio code (single API)
    </li>
    <li class="slide">
      Controllers are Daimio code sent to server
    </li>
    <li class="slide">
      Models are mechanically robust 
    </li>
    <li class="slide">
      But ignorant of 'soft' parts
    </li>
    <li class="slide">
      Perms and attrs handle the fluffy bits.
    </li>
  </ul>
</section>


<section class="slide" id="concpar1">
  <h2>Concurrency vs Parallelism</h2>
  <ul>
    <li>
      You have 1,000 independent tasks to perform
    </li>
    <li>
      Each takes 1 second
    </li>
    <li>
      One core? 1,000 seconds
    </li>
    <li>
      Four cores? ~250 seconds
    </li>
    <li>
      Parallelism is easy
    </li>
  </ul>
</section>

<section class="slide" id="concpar2">
  <h2>Concurrency vs Parallelism</h2>
  <ul>
    <li>
      You have 1,000 independent tasks to perform
    </li>
    <li>
      Each takes 1 second, but requires no processing
    </li>
    <li>
      With concurrency? ~1 second
    </li>
  </ul>
</section>

<section class="slide" id="concpar3">
  <h2>Concurrency vs Parallelism</h2>
  <ul>
    <li>
      You have 1,000 independent tasks to perform
    </li>
    <li>
      Each takes 1 second, but requires no processing
    </li>
    <li class="slide">
      Except it initially reads a counter, then increments it when done
    </li>
    <li class="slide">
      ...
    </li>
    <li class="slide">
      Concurrency is hard.
    </li>
  </ul>
</section>

<section class="slide" id="concpar3">
  <h2>Concurrency</h2>
  <ul>
    <li>
      JS avoids critical section issues
    </li>
    <li>
      Unless you go async, but it's obvious when that happens
    </li>
    <li class="slide">
      Unless it isn't...
    </li>
    <li class="slide">
      Spaces confine state
    </li>
    <li class="slide">
      And have rules to limit concurrency.
    </li>
  </ul>
</section>


<section class="slide" id="makes-it-tick">
  <h2>Techniques that make Daimio tick</h2>
  <ul>
    <li>
      Technique 1: Trampoline
    </li>
    <li>
      Technique 2: NaN poison
    </li>
    <li>
      Technique 3: MungeLR
    </li>
  </ul>
</section>

<section class="slide" id="tramp1">
  <h2>#1: Trampolines</h2>
  <ul>
    <li>
      Magical async makes you think of CPS
    </li>
    <li class="slide">
      CPS gives us control over async (just call cont instead of return)
    </li>
    <li class="slide">
      JS: no native continuations, but we have closures
    </li>
    <li class="slide">
      No TCO, though, so the call stack explodes
    </li>
    <li class="slide">
      Answer: trampoline!
    </li>
  </ul>
</section>

<section class="slide" id="tramp2">
  <h2>Trampolines</h2>
  <pre><code>
function trampoline(x) {
  while (x && x.fun)
    x = x.fun.apply(null, x.args)
}

function f(callback){
  return ++n > 1000 ? callback(n) : {fun:f, args:[callback]}
}

n = 0; start = Date.now(); trampoline({fun:f, args:[function() {console.log(Date.now() - start)}]})
  </code></pre>
</section>

<section class="slide" id="tramp3">
  <h2>Trampolines</h2>
  <ul>
    <li>
      We need to trampoline every time we might go async
    </li>
    <li>
      So map, reduce, filter -- anything that accepts a pipeline
    </li>
    <li>
      Let's make it as easy as possible
    </li>
  </ul>
</section>

<section class="slide" id="tramp4">
  <h2>Daimio Map</h2>
  <pre><code>function(data, block, prior_starter, process) {
  var scope = {}
  
  var processfun = function(item, prior_starter) {
    scope["*in"] = item
    return block(function(value) 
      {prior_starter(value)
    }, scope, process)
  }

  return D.dataTrampoline(data, processfun, D.list_push, prior_starter)
}
  </code></pre>
</section>

<section class="slide" id="tramp5">
  <h2>Daimio Data Trampoline</h2>
  <pre><code>function(data, processfun, joinerfun, finalfun, prior_starter) {
  var keys = Object.keys(data)
    , size = keys.length
    , index = -1
    , result = joinerfun()
    , asynced = false
    , value

  finalfun = finalfun || D.identity

  var inner = function() {
    while(++index < size) {
      var key = keys[index]
      value = processfun(data[key], my_starter, key, result)
      if(value !== value) {
        asynced = true
        return NaN
      }
      result = joinerfun(result, value)
    }

    if(asynced)
      return prior_starter(finalfun(result))

    return finalfun(result)
  }

  var my_starter = function(value) {
    result = joinerfun(result, value)
    inner()
  }

  return inner()
}
  </code></pre>
</section>

<section class="slide" id="stack1">
  <h2>#2: Poisoning the Stack</h2>
  <ul>
    <li>
      Everything has to pass a callback in case of async
    </li>
    <li class="slide">
      If you go too deep you blow the stack
    </li>
    <li class="slide">
      So return if you don't go async
    </li>
    <li class="slide">
      But now you have two processes
    </li>
  </ul>
</section>

<section class="slide" id="stack1">
  <h2>Poison is the solution</h2>
  <ul>
    <li>
      Solution: return a proper value if sync
    </li>
    <li class="slide">
      Return poison on async
    </li>
    <li class="slide">
      We use NaN for poison
    </li>
    <li class="slide">
      <pre><code>if(value !== value) return NaN</code></pre>
    </li>
  </ul>
</section>

<section class="slide" id="stack1">
  <h2>Stack Inversion</h2>
  <ul>
    <li>
      On re-entry, the stack is built backwards, from the innermost function up
    </li>
    <li>
      Those new layers are the skeletal remains of the past adventure
    </li>
    <li>
      The remain until the process completely ends (return cascade)
    </li>
    <li>
      Or the next async call smashes the stack
    </li>
  </ul>
</section>

<section class="slide" id="munge1">
  <h2>#3: The Munger</h2>
  <ul>
    <li>
      Say you have a list of items
    </li>
    <li>
      And you want to process each with a function
    </li>
  </ul>
  <pre><code>
     _ _ _ _ _ _ _ _ _ _ _
    |_|_|_|_|_|_|_|_|_|_|_|
    
     | | | | | | | | | | |
 f   | | | | | | | | | | |
     v v v v v v v v v v v
     _ _ _ _ _ _ _ _ _ _ _
    |_|_|_|_|_|_|_|_|_|_|_|
  </code></pre>
  <ul class="slide">
    <li>
      Map!
    </li>
  </ul>
</section>

<section class="slide" id="munge2">
  <h2>Maps in JS</h2>
  <pre><code>[1, -2, 3.14].map( Math.abs )</code></pre>
  <pre class="slide"><code>[42, 3.14, 1234e-2].map( Math.round )</code></pre>
  <pre class="slide"><code>["", 0, [], {}, null, NaN].map( Boolean )</code></pre>
  <pre class="slide"><code>["1", "2", "xyzzy", "3"].map( parseFloat ).map( isNaN )</code></pre>
</section>

<section class="slide" id="munge3">
  <h2>More Munging</h2>
  <ul>
    <li>
      Say each item produces a list under f
    </li>
    <li>
      And you want the list of all subitems produced
    </li>
    <p class="slide"><img src="../map-cat.jpg"></img></p>
  </ul>
</section>

<section class="slide" id="munge4">
  <h2>Mapcat in JS</h2>
  <pre><code>[].concat.apply([], 
  [{x:1,y:2}, {z:3}, {q:4,p:5}].map( Object.keys ))</code></pre>
  <ul>
    <li class="slide">
      What if an item is 'empty' under f?
    </li>
    <li class="slide">
      Does it leave a hole? We don't want a hole.
    </li>
  </ul>
  <pre class="slide"><code>[].concat.apply([], 
  [{x:1,y:2}, {z:3}, {}, {}, {q:4,p:5}].map(Object.keys))</code></pre>
  <p class="slide">
    Still works!
  </p>
</section>

<section class="slide" id="munge5">
  <h2>More Munging</h2>
  <ul>
    <li>
      What if we want to do this recursively?
    </li>
    <li class="slide">
      Recursive mapcat?
    </li>
    <li class="slide">
      What if items need to poke other items?
    </li>
    <li class="slide">
      Oh dear.
    </li>
  </ul>
</section>

<section class="slide" id="munge6">
  <h2>The Munger</h2>
  <pre><code>function(items, fun) {
  var L = []
    , R = items
    , item = {}
    , result = []

  if(!items.length) return items

  do {
    item = R.shift() // OPT: shift is slow
    result = fun(L, item, R)
    L = result[0]
    R = result[1]
  } while(R.length)

  return L
}</code></pre>
</section>

<section class="slide" id="munge7">
  <h2>The Munger in use</h2>
  <pre><code>function(L, segment, R) {
  var type = D.SegmentTypes[segment.type]
  if(!type) return [L, R] // no know type
  if(!type.munge_segments) return [L.concat(segment), R]
  return type.munge_segments(L, segment, R)
}
  </code></pre>
</section>


<section class="slide" id="finally">
  <h2>Wait a second</h2>
</section>

<section class="slide" id="finally">
  <h1 style="font-size:1em;">
    <p style="font-size:1.5em; color:red">http://sherpa.local:8008</p>
    <p>
      dann @ bentobox . net
    </p>
    <p>
      @dann
    </p>
  </h1>
</section>




<!-- Grab CDN jQuery, with a protocol relative URL; fall back to local if offline -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../jquery-1.7.2.min.js"><\/script>')</script>

<!-- Deck Core and extensions -->
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>

<!-- Initialize the deck -->
<script>
$(function() {
	$.deck('.slide');
});
</script>

</body>
</html>
