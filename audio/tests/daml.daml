WELCOME TO DAML

// TEMP

{daml alias string "audio add-osc freq" as :osc}

{daml alias string "audio add-gain value" as :gain}

{daml alias string "audio set-param name" as :set}

{daml alias string "audio play" as :play}

{daml alias string "audio pause" as :pause}

{daml alias string "audio connect" as :connect}

{daml alias string "audio connect to 0" as :out}



{/osc 5 | > :lfo | gain 80 | osc | out | play}
true
{/lfo | set :frequency to 1}
1
{/lfo | set :frequency to 10}
1

{/osc 5 | gain 80 | osc | audio mainline | play}

// DAML.run('{osc 5 | gain 80 | osc | audio mainline | play}')



// interesting: http://www.g200kg.com/en/docs/webmodular/index.html?p=1F2B3H5H8091BHCAE2H2IHK3N6Q4T7WIY5Z4aEc3dH_0021CPo500021COo00Ze0nNoR0l00Qnoo0Z00Ko00Z00no00oRoe00o0201P1000b&m=t150%0Ae-d-%3Cg-4%3Eg-rg-4e-d-%3Cg-4%3Eg-rg-4e-d-%3Cg-4%3Eg-4%3Ce-4%3Eg-4%3Cd-4%3Efrf4%0Ae-d-%3Cd-4%3Efrf4e-d-%3Cd-4%3Efrf4e-d-%3Cd-4%3Ef4%3Ce-4%3Ef4%3Cg-4%3Eg-rg-4



This document servers as a primer, tutorial, reference, test suite and specification for future implementations of the DAML language.

DAML is a thin, narrow, safe language designed as a container for your application's functionality, to allow scripting and templating by people who aren't you. It's thin in the sense that the base language is right under the surface, narrow in that it only has five elements (strings, numbers, lists, commands, and pipes), and safe as in untrusted code can be run on your server.

All DAML commands are wrapped in braces. Within this test document the line directly beneath a DAML command is the expected output, and a test will fail if it isn't matched.

At one point in the development of DAML I managed to reduce the entire language to numbers, strings, and commands. Blocks, pipes, and variables were all parse-equivalent to commands: string join, process pipe and variable get, respectively. I've since brought those features further down into the parsing/interpreting process for efficiency's sake, but there's nothing in the language definition itself that would require that, and in fact it's a fairly quick way to get DAML running on another platform.

// TODO:
 - have an 'event' tag for commands, which pushes the command (plus date, user, etc) into the history: this can be replayed later to rebuild the entire application state. Only things that record their own history (audit answers, maybe) and things that don't change state (find commands) should not have this. Could record it like {house paint hue 128 saturation 100} ==> {h: "house", m: "paint", p: {hue: 128, saturation: 100}} ... [can imported commands have tags? like, for marking a sequence of actions as a 'composite' in some sense, or like a transaction... because you might add a new thing, with a lot of content, but each item of content is added as a separate command. so you might want to 'cluster' that somehow...]
 - blessing happens at the content level, probably... which makes content pretty important.
 - maybe no commands touch external gateways (payment, email, etc) directly... those could go through hippos / AQ instead. which makes it easier to turn those off when replaying event sequences, and manipulate them on local/staging/demo etc. but what about a command that has to return the result of performing an external action?
 
 To notebook: use space+key as meta, pointless programming (no variables), help dictionary for keybindings (emacs), more recursive combinators in daml, monads in daml for guarding variables etc?, virtual edge when you click a port that tracks your mouse, ...
 
Keyed lists: the position of an item in the list is not a key. Items can always be retrieved by positional index. Items can also be keyed. Sorting, grouping, and other such operations preserve keys. Remember to use #N to access by position. @foo.{"#{pos}"} works also. @foo.(:#2 :#4 :alpha 7) also works, though this also means you can never key an array with '#N' where N is an integer, so... actually, that's probably fine.

Schema: a list of collections and the mechanical fields (ie non-attr, non-perm) fields inside them. used by the mongo layer to do automatic type conversion. maybe used to verify validity of objects. also for data migrations (much easier to see if it's all in one place, and may even be possible to automate sometimes). prevents weird string->int->string casting bugs. so a pretty convenient thing for larger apps. might not be mandatory... but really, with all soft data in attrs, there's almost no reason not to always use it: you have to have a schema somewhere, either scattered through your code or in one place. so stick it one place.

orthogonal setters vs unified add: always use empty add + validator. data schema may help with that.

{let :plural on :value be "{value | is like :1 | not | then :s}"}
let -> daml import into :etc key 
plus aliasing...
{@count | plural}

did i mention that fancy handlers return a function that takes into account the local scope, var name/path, etc and that a call to this fancy function is placed in the fing but then it could be pre-run in the stack? 

{(1 2 3) | > (:a :b :c)}
{(1 2 3 4 5) | > (:first "..." :last)}
{(1 2 3 4 5) | > (:head "...tail")}
---- look up more destructuring examples






Tests in DAML:
- are end-to-end integration tests
- unit test your methods
- serve as documentation
- run on client and server
- serve as scaffolding for building models
  [write DAML first]
- can be tested for coverage
- 



{begin add_edge | daml import into : in (:v1 :v2) out :1}
  
{end add_edge}


SOME STUFF THAT'S HERE FOR NOW

unionizer: 
  {(1 2 3) | union (4 5 6)}
  [1,2,3,4,5,6]
  
  {union ((1 2 3) (4 5 6))}
  [1,2,3,4,5,6]
  
  {* (:x 1 :y 2) | union {* (:z 3 :a 4)} }
  {"x":1,"y":2,"z":3,"a":4}
  

fing problem:
  { ((1 2 3) 2 3) | extract "{and (1 1)}"}
    [[1,2,3],2,3]

counting problem (should count non-lists as 0):
  { ((1 2 3) 2 3) | extract "{this | count}"}
    [[1,2,3]]

Tests for switch
  ham?
    {logic switch on 2 value (1 :one 2 :two 3 :three)}
      two
    
    {logic switch on {:asdf | string slice start 2} value (:as 1 :sd 2 :df 3)}
      3

Tests for fings
  this should return nothing, because we should cancel the fing's status when trying to add to it
    {"{:foo}x" | > :xxx || 123 | > :xxx.y | xxx.string}
  
  make sure we're not defuncing pre-merge
    {"{:foo}x" | > :qq.ww.ee || merge data qq daml "{ee | quote}"}
      {:foo}x
  

Tests for stringification
  {1 | > :power || each data (1 2 3 4) daml "{math pow value 2 exp power | > :power} "}
    2 4 16 65536

Tests for strings
  truncate
    {"four sixsix four" | string truncate to 10}
      four
    {"four sixsix four" | string truncate to 11}
      four sixsix
    {"foursixsixfour" | string truncate to 10}
      foursixsix
    {"four sixsix four" | string truncate to 10 add "..."}
      four...
    {"four sixsix four" | string truncate to 11 add "..."}
      four sixsix...
    {"foursixsixfour" | string truncate to 10 add "..."}
      foursixsix...
    
    
Tests for pipes
  ensure we're not front-piping: the initial command segment shouldn't get pipe vars
    {math pow value 5 exp 0}
      1
    
    (should fail with error, no exp)
    {math pow value 5}
    
    (should still fail)
    // TODO: ensure we're not front-piping inside pipes
    // (this might have to wait until the big rebuild)
    {math pow value 5 | > :vvvvv}
    
    (ss should fail with error, so zero value)
    {3 | math pow value {string split}}
      0

  ok, but what about this?
    {begin walk | merge data ({* (:a {* (:s 1)} )}) }{a.s}{end walk}
      1
    
    {begin walk | merge data ({* (:a {* (:s 1)} )}) }x{a.s}{end walk}
      x1
    
    {merge data ({* (:a {* (:s 1)} )}) daml "{a.s}"} 
      1
    
Tests for lists
  Sort and reverse
    {(3 2 4 1) | list reverse}
      [1,4,2,3]
    {(3 2 4 1) | list sort}
      [1,2,3,4]
    {(3 2 4 1) | list sort | list reverse}
      [4,3,2,1]
    
    {( {* (:x 2 :y :d)} {* (:x 1 :y :d)} {* (:x 3 :y :a)} {* (:x 2 :y :c)} {* (:x 4 :y :b)} ) | > :klist}
      [{"x":2,"y":"d"},{"x":1,"y":"d"},{"x":3,"y":"a"},{"x":2,"y":"c"},{"x":4,"y":"b"}]
      
    {klist | list sort by :x | __.x}
      [1,2,2,3,4]

    {klist | list sort by :y | list reverse | __.y}
      ["d","d","c","b","a"]

    {klist | list sort by "{(this.x this.y) | string join}" | merge daml "{x}{y} "}
      1d 2c 2d 3a 4b

    {klist | list sort by "{(this.y this.x) | string join}" | map daml "{value.y}{value.x}"}
      ["a3","b4","c2","d1","d2"]

    // extract
    // THINK: why do we need all the 'then 1's?
    {klist | list extract daml "{this.x | eq 2 | then 1}"}
      [{"x":2,"y":"d"},{"x":2,"y":"c"}]
      
    {klist | list extract daml "{this | eq :d | then 1}" path "*"}
      ["d","d"]
      
    {( {* (:one (2 3 5) :two (1 3 4))} {* (:one (3 4 5) :two (1 3 4))} ) | > :dlist ||}
    
    {dlist | list extract daml "{this | less than :4 | then 1}" path "*.*"}
      [2,3,1,3,3,1,3]
    
    {dlist | list extract daml "{parent.parent.one.1 | eq :3 | then 1}" path "*.one"}
      [2,3,5]
    

      // // prune
      // {list prune value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {this | less than :4} path "*.*"}
      // [{"one":{"2":"5"},"two":{"2":"4"}},{"one":{"1":"4","2":"5"},"two":{"2":"4"}}]
      // 
      // {list prune value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {parent.parent.one.1 | eq :3} path "*.*"}
      // [{"one":[],"two":[]},{"one":["3","4","5"],"two":["1","3","4"]}]
      // 
    

Tests for falseness
  Empty strings, arrays, and hashes are false, as is the number zero and unset vars.
    {"" | then :true else :false}
      false
    {0 | then :true else :false}
      false
    {x | then :true else :false}
      false
    {() | then :true else :false}
      false
//    {* () | then :true else :false}
//      false
// TODO: make a hash, then remove the key (the above errors, because you have to have at least two values to pair)
// OOOOOOR... allow empty hashes (and one-val'd hashes), which make an empty fillable object thing.
  
  The string "0", whitespace, and stuff with things in them are true.
    {" " | then :true else :false}
      true
    {"0" | then :true else :false}
      true
    {(false) | then :true else :false}
      true
    {(0) | then :true else :false}
      true
    {* (0 false) | then :true else :false}
      true

  Some parameters are required to have a non-false value. The below fails with an error.
    {3 | > ""}


Tests for pass-by-value. Changing a DAML variable shouldn't change other variables, either in DAML or in the base language.
  {(1 2 3 4) | > :x}
    [1,2,3,4]
    
  {x | > :y}
    [1,2,3,4]
    
  {5 | > :x.{x | count}}
    5
    
  {x} x {y}
    [1,2,3,4,5] x [1,2,3,4]


Tests for self-reference. PBV cures these ills.
  {* (:a 1 :b 2) | > :x | > :x.c}
    {"a":1,"b":2}
    
  {x | > :x.d}
    {"a":1,"b":2,"c":{"a":1,"b":2}}
    
  {x}
    {"a":1,"b":2,"c":{"a":1,"b":2},"d":{"a":1,"b":2,"c":{"a":1,"b":2}}}


Tests for array compilation:
  {"{add (counter 1) | > :counter}" | > :countfing}
    1
  
  {countfing}
    2
  
  {countfing | run | counter}
    3


Tests for weird variables and stuff: 
  return nothing, as it's not a shortcut or variable.
    {+foo | > :ok}
  
  leading underscores are ok
    {12 | > :_foo | _foo}
      12

// other stuff

{:dann | > :name}
  dann

Quoting a string passes the DAML through unscathed.
  {"hi {name}" | quote}
    hi {name}

Additional braces are irrelevant. (Internal braces are merely for grouping.)
  {{"hi {name}"} | quote}
    hi {name}

Running the DAML first changes the output.
  {"hi {name}" | run | quote}
    hi dann

  {{"hi {name}" | run} | quote}
    hi dann

The quote command also works on arrays.
  {"hi {name}" | string split on " " | quote}
    ["hi","{name}"]


Once more, with feeling


{({* (:name :youhoo)}) | > :names}
[{"name":"youhoo"}]

{"hey {name}!" | > :foo}
hey dann!

{:blargh | > :name}
blargh

{merge data names daml foo}           {/ var get => fing}
hey youhoo!         
                    
{merge data names daml {foo}}         {/ same}
hey youhoo!
           
{merge data names daml "{foo}"}       {/ new fing => var get => old fing}
hey youhoo!
  
{merge data names daml {"{foo}"}}     {/ same}
hey youhoo!
  
{merge data names daml "{foo} x"}     {/ different new fing}
hey youhoo! x
  
{merge data names daml {"{foo} x"}}   {/ same different new fing}
hey youhoo! x
    
{merge data names daml {foo | run}}   {/ var get => fing => defunc => string}
hey blargh!


--> merge over an object instead of an array

{* (:one {* (:name :youhoo)} ) | > :names}
  {"one":{"name":"youhoo"}}

{merge data names daml foo}
  hey youhoo!  


---> inside a parameter, braces around quotes are redundant. 

{variable set path :foo value 123}
123

{variable set path :string_foo value "{foo} ~"} 
123 ~

{variable set path :run_foo value {"~ {foo}"}}
~ 123

{string_foo}{run_foo}
123 ~~ 123

{variable set path :foo value :asdf}
asdf

{string_foo}{run_foo} 
asdf ~~ asdf


Here's the use cases, from the user's perspective:
{variable set path :foo value 123}
  123

- I put a simple string in, I want the same string out.
  {"asdf"}
    asdf
  {begin x | x}asdf{end x}
    asdf

- I put a simple string in, do some regex substitution, and get the evolved string out.
  {string transform value "asdf" from "d" to "x"}
    asxf
  {string transform value "asdf" from "/[d]/" to "x"}
    asxf
  {string transform value "asdfdd" from "/[d]/" to "x"}
    asxfdd
  {string transform value "asdfdd" from "/[d]/g" to "x"}
    asxfxx

- transformations can accept daml, also. the 'this' variable is loaded with matches.
  {"food mood wood" | string transform from "/oo/g" to "{this | string uppercase}"}
    fOOd mOOd wOOd

- I put a DAML string in with escape characters, and want the raw DAML string out.
  ---- WELL ACTUALLY: DAML doesn't have escape characters anymore.
  {// {"\{asdf\}"} //}
    

- I pass/pipe a DAML string in to the quote command, and want the raw DAML string out.
  {daml quote value "{asdf}"}
    {asdf}
  {"{asdf}" | daml quote}
    {asdf}

- I put a DAML string in, and want the processed output.
  {"{foo}x"}
    123x

- I put a DAML string in, get the processed output, and put that in a variable.
  {variable set path :x value {"{foo}x" | run}}
    123x
  {x}
    123x
  {variable set path :foo value 321}
    321
  {x}
    123x

- I put a DAML string in to a variable, then invoke that variable later (getting the processed output in each new context).
  {variable set path :x value "{foo}x"}
    321x
  {x}
    321x
  {variable set path :foo value 123}
    123
  {x}
    123x

- I put a DAML string in to a variable, then use that variable as a template for merging.
  {variable set path :z value "~{value}~"}
    ~~
  {each daml z data (1 2 3)}
    ~1~~2~~3~
  
- I pass a DAML string in as a template for merging.
  {each daml "~{value}~" data (1 2 3)}
    ~1~~2~~3~
  
- I create a DAML string, do substitutions on it, and then pass it in as a template for merging.
-----> this one is weird, because the inner command should *fully* process the string.
---- note the 'unquote' command, which processes the tainted strings.
  {each daml {string transform value "~{value}~" from "~" to "!" | unquote} data (1 2 3)}
    !1!!2!!3!
  {string transform value "~{value}~" from "~" to "!" | unquote | each data (1 2 3)}
    !1!!2!!3!
  {"~{value}~" | string transform from "~" to "!" | unquote | each data (1 2 3)}
    !1!!2!!3!
  
- I take a DAML string, get its ptree, do some mangling (macros), then get the processed output.
------> THINK: do we want this in here? I'm taking it out for now because it's kind of silly.
//  {daml parse string "x{foo}y"}
//    {"m":"string","f":"join","p":{"value":["x",{"m":"variable","f":"get","p":{"path":"foo"}},"y"]}}
//  {variable set path :xy value {daml parse string "x{foo}y"}}
//    {"m":"string","f":"join","p":{"value":["x",{"m":"variable","f":"get","p":{"path":"foo"}},"y"]}}
//  {variable set path :xy.p.value.#3 value "z"}
//    z
//  {xy}
//    x123z

- I take a DAML string, pass it to the server, capture the (possibly object) return value and use it.

  

- ensure all strings get fully processed
  {"{"{"{1} 2"} 3"} 4"}
    1 2 3 4
  
  {{"{"{"{1} 2"} 3"} 4"}}
    1 2 3 4

  {"{"{"{1} 2"} 3"} 4" | quote}
    {"{"{1} 2"} 3"} 4
  
- ensure strings stay as strings:
  {> :z value "z"}
    z
  {> :key value "KEY"}
    KEY

  ---- this section highlights the new 'tainting' aspect of DAML. Strings from foreign sources (db, user input, etc) aren't processed unless explicitly instructed. Also, string transformations taint the source string, and will only process when requested. 
  
  For reference, this is how you immediately run tainted strings:
    {"x{key}y{z}" | string transform from "{key}" to 123 | run}
      x123yz

  And this is how you prep them for running eventually:
    {"x{key}y{z}" | string transform from "{key}" to 123 | unquote}
      x123yz

  And these are all transformed, hence tainted:

  {"x{key}y{z}" | string transform from "{key}" to 123}
    x123y{z}
  {begin block | string transform from "{key}" to 123}x{key}y{z}{end block}
    x123y{z}
  {block | string transform from "{key}" to 123}
    x123y{z}
  {> :x value "x{key}y{z}" | string transform from "{key}" to 123} {// as a var}
    x123y{z}
  {"x{key}y{z}" | > :x1 | string transform from "{key}" to 123} {// through a pipe}
    x123y{z}
  {string transform value "x{key}y{z}" from "{key}" to 123}
    x123y{z}
  {string transform value {"x{key}y{z}"} from "{key}" to 123}
    x123y{z}
  {string transform value {{"x{key}y{z}"}} from "{key}" to 123}
    x123y{z}
  {string transform value x from "{key}" to 123}
    x123y{z}
  {string transform value {x} from "{key}" to 123}
    x123y{z}
  {string transform value {{x}} from "{key}" to 123}
    x123y{z}
  {string transform value x1 from "{key}" to 123}
    x123y{z}
  {string transform value {x1} from "{key}" to 123}
    x123y{z}
  {string transform value {{x1}} from "{key}" to 123}
    x123y{z}
  {string transform value block from "{key}" to 123}
    x123y{z}
  {string transform value {block} from "{key}" to 123}
    x123y{z}
  {string transform value {{block}} from "{key}" to 123}
    x123y{z}
  
- ensure we can fully process if necessary
  {string transform value {x | run} from "{key}" to 123}
    xKEYyz
  {string transform value {x1 | run} from "{key}" to 123}
    xKEYyz
  {string transform value {block | run} from "{key}" to 123}
    xKEYyz
  
- ensure we can also access it as a function

  {"x{key}y{z}" | each data (1 2)}
    x0yzx1yz
  {begin block | each data (1 2)}x{key}y{z}{end block}
    x0yzx1yz
  {block | each data (1 2)}
    x0yzx1yz
  {> :x value "x{key}y{z}" | each data (1 2)} {// as a var}
    x0yzx1yz
  {"x{key}y{z}" | > :x1 | each data (1 2)} {// var via pipe}
    x0yzx1yz
  {each daml "x{key}y{z}" data (1 2)}
    x0yzx1yz
  {each daml {"x{key}y{z}"} data (1 2)}
    x0yzx1yz
  {each daml {{"x{key}y{z}"}} data (1 2)}
    x0yzx1yz
  {each daml x data (1 2)}
    x0yzx1yz
  {each daml {x} data (1 2)}
    x0yzx1yz
  {each daml {{x}} data (1 2)}
    x0yzx1yz
  {each daml x1 data (1 2)}
    x0yzx1yz
  {each daml {x1} data (1 2)}
    x0yzx1yz
  {each daml {{x1}} data (1 2)}
    x0yzx1yz
  {each daml block data (1 2)}
    x0yzx1yz
  {each daml {block} data (1 2)}
    x0yzx1yz
  {each daml {{block}} data (1 2)}
    x0yzx1yz

----- Loading value into the value variable creates a self-referencing fing, which affects us later... 
// what we want to show here is that editing a fing changes it back into just a regular 'dead' string.
{begin x_to_y}
  {string transform value value from x to y}
{end x_to_y}

{x_to_y}

{"axy fix hex hoax" | > :value || :x | > :x || :y | > :y || x_to_y}
  ayy fiy hey hoay

{x_to_y | > :value | x_to_y | run | > :modded_fing}
  {string transform value value from y to y}

{modded_fing}
  {string transform value value from y to y}

// and then show you can 'rez' a dead string by unquoting it. (unquoting is dark, necromantic magic.)

{x_to_y | > :value | run}
  {string transform value value from y to y}

// alternately:
{x_to_y | string transform from :x to :z | string transform from :y to :x | string transform from :z to :y | > :y_to_x}
  {string transform value value from y to x}
  
{"axy fix hex hoax" | > :value || :x | > :x || :y | > :y || y_to_x}
  {string transform value value from y to x}


// run the process instantly
{"axy fix hex hoax" | > :value || :x | > :x || :y | > :y || y_to_x | run}
  axx fix hex hoax

{y_to_x | run | quote}
  axx fix hex hoax


// unquote the string to create a fing
{y_to_x | unquote | > :y_to_x_fing}
  axx fix hex hoax

{y_to_x | unquote | quote}
  {string transform value value from y to x}

{"axy faxy foxy" | > :value || y_to_x_fing}
  axx faxx foxx
  

// make the above into a command, with proper parameters


-- let's examine strings in strings in braces etc

{:z | > :z}
z
{"" | > :y}

// this one's pretty easy -- just make sure you fully process before you finish
{"1 {z} {"2 {z} {"3 {z}"}"}"}
1 z 2 z 3 z

// this one's a bit harder -- once it starts running, the first command should fully proc before the next one
{"1 {"{y} 2 {z | > :y} 3"} {y}"}
1  2 z 3 z

// ho ho ho
{1 | > :x}
1

{({"{x}" | > :asdf} "zxcv" {"{x}"} asdf) | string join on " "}
1 zxcv 1 1

{({"{x}dog" | > :asdf} asdf {8 | > :x} asdf) | string join on " "}
1dog 1dog 8 8dog
    
{1 | > :x}
1

-- note here that the entire list gets processed before the 'on' param's DAML is processed. this is due to the internal mechanics of 'string join': some commands may behave differently. 
{(asdf {"{x}" | > :asdf} "zxcv" {"{x}"} asdf) | string join on " {asdf} "}
1dog 1 1 1 zxcv 1 1 1 1

{({"{x}dog" | > :asdf} asdf {8 | > :x} asdf) | string join on " {x} "}
1dog 8 1dog 8 8 8 8dog
    
END STUFF


:::The Five Elements of DAML:::

Element 1: Numbers

  Wrap a number in braces and you've got a DAML number. Note that while the exponential and hex number formats work, they aren't required in the spec. Avoid them where possible.

    Ints n' floats:
      {0}
      0
      {65535}
      65535
      {3.14159}
      3.14159
  
    Exponential notation:
      {3e10}
      30000000000
      {3e+10}
      30000000000
      {3e-3}
      0.003
      {3e80}
      3e+80
    Hex converts: 
      {0x777}
      1911
    Octal doesn't:
      {0777}
      777
    

Element 2: Strings

  Primitive strings are quite simple. We'll see a way of handling complicated strings (with embedded quotes, e.g.) later.
  
    Strings are enclosed in double-quotes:
      {"hello world"}
      hello world
    A single word can be colon-quoted:
      {:xyzzy}
      xyzzy


Element 3: Lists
  
  Lists are the basic data structure of DAML. Spaces separate items. List items can be any valid expression.
  Notice that data structures are implicitly converted to JSON when forced to take string form.
  
    A list of random numbers:
      {(8 6 7 5 3 0 9)}
      [8,6,7,5,3,0,9]
  
    A list of pleonasms:
      {("free gift" "true fact" "revert back" "hot water heater" "tired cliche")}
      ["free gift","true fact","revert back","hot water heater","tired cliche"]
  
    Numbers and strings:
      {(1 "a sandbox" 2 "a sandbox")}
      [1,"a sandbox",2,"a sandbox"]
    
    A list of lists:
      {((1 2 3) (:once :twice :thrice) (:primary :secondary :tertiary))}
      [[1,2,3],["once","twice","thrice"],["primary","secondary","tertiary"]]

    The first three ordinals:
      {( () (()) (() (())) )}
      [[],[[]],[[],[[]]]]
  

Element 4: Commands

  The essence of DAML is commands. Every command has a model (the first word) and a function (the second).

    The simplest command would look like this:
      {fruit slice}
  
  But because we haven't published the 'fruit' model into this DAML dialect that won't do anything.
  
  Most commands take parameters, which are named. A parameter value can be a string, a number, a list or a command. [THINK: can it be a block??]

    A slightly fancier (but still non-functional) command:
      {fruit slice with :katana}

  The following commands use models that are published by default.
  
    Join an array of strings:
      {string join value (:barbera :belvest :brioni)}
      barberabelvestbrioni
  
    With the optional 'on' parameter:
      {string join value (:barbera :belvest :brioni) on ", "}
      barbera, belvest, brioni
  
    Parameter order is arbitrary:
      {string join on " > " value (:barbera :belvest :brioni)}
      barbera > belvest > brioni
  
    We can split things, too:
      {string split value "selvedge balmoral aglet placket plimsolls" on " "}
      ["selvedge","balmoral","aglet","placket","plimsolls"]


Element 5: The pipe operator

  You can use the pipe ('|') to pass the output of one command into an input of another.
  
    Split, then join:
      {string split value "shantung weft repp slub" on " " | string join on ", "}
      shantung, weft, repp, slub
  
    Split, filter, join:
      {string split value "shantung weft repp slub" on " " | string grep on :s | string join on ", "}
      shantung, slub
  
  
  In some ways the pipe is syntactic sugar for *commands as parameter values*, though the two differ slightly in implementation. The following commands are essentially equivalent to the above pipelines.
  
    Split, then join:
      {string join on ", " value {string split value "shantung weft repp slub" on " "}}
      shantung, weft, repp, slub
  
    Split, filter, join:
      {string join on ", " value {string grep on :s value {string split value "shantung weft repp slub" on " "}}}
      shantung, slub

  Pipelines can make complicated DAML statements much easier to read, and lend themselves to dataflow-style programming. They're generally preferred over embedded commands.
  
    You can also pipe parameters, which sometimes improves readability:
      {(:bebop :hardbop :cool :swing) | string join on ", "}
      bebop, hardbop, cool, swing

    A single pipe at the end of a command passes the value through:
      {:asdf|}
      asdf

    A double pipe in a command squelches the pipe value:
      {:asdf ||}
      
    
    Which is equivalent to:
      {:asdf | ""}
      
    
    Squelching is useful sometimes, when you want to continue a pipeline without passing the previous value:
      {:asdf | string join value (:one :two)}
      oneasdftwo
      {:asdf || string join value (:one :two)}
      onetwo
    
    Though you could also do that like this:
      {:asdf ||}{string join value (:one :two)}
      onetwo
  

:::Quick Notes:::

If you're familiar with other programming languages you'll notice that DAML seems to be missing many basic necessities: control statements like if-then-else, loop statements, function declaration, variable assignment, and the list goes on. These facilities exist within DAML as commands. This means that for-loops, for example, return a value (as do all commands). It also means that you can add new basic concepts to the language just by publishing new commands.


:::Sugary Snacks:::

DAML provides some syntactic sugar for simplifying certain common operations.

Snack 1: Variables

  Variables in DAML aren't built-in -- they're actually provided by commands published from the base language. Some sugar is provided to make accessing variable values easier.

    You can use this command to set a variable:
      {variable set path :bar value (:one :two :three)}
      ["one","two","three"]
  
    And this command retrieves the variable value:
      {variable get path :bar}
      ["one","two","three"]
  
    But you can also use this shorter form:
      {bar}
      ["one","two","three"]
  
    You can push things deeper into a variable using a dot ('.'):
      {variable set path :foo.one value :xyzzy}
      xyzzy
  
    You can reach in to variables the same way:
      {foo.one}
      xyzzy

    Use an octothorp to find the Nth value in a list:
      {bar.#2}
      two
  
    Negative indices are also supported:
      {bar.#-1}
      three
  
  We'll see some more ways to reach into variables in a bit.
  

Snack 2: Blocks

  A block encloses text. [Could be a template, or some DAML code (or a mix). they're equivalent to a string join + context + var. discuss var scope]
  
    Here's a simple block:
      {begin foo}Some text{end foo}
  
    Notice that it doesn't output anything. What if we pipe it into a command?
      {begin foo | string split on " "}Some text{end foo}
      ["Some","text"]
    
    The block also creates a new variable:
      {begin foo}Some text{end foo}{foo}
      Some text
      {begin foo | foo}Some text{end foo}
      Some text

  We squelch the output of blocks that don't pipe the 'begin' statement as a convenience. Usually unpiped blocks are built as templates for later use.
  
    Using a block we've previously built:
      {foo | string split on " "}
      ["Some","text"]
    
    Blocks can also contain DAML:
      {begin foo}x{value}-{end foo}
    
    The each command invokes a DAML string for every element of a list. These are all equivalent:
      {each daml "x{value}-" data (1 2 3)}
      x1-x2-x3-
      {each daml {"x{value}-"} data (1 2 3)}
      x1-x2-x3-
      {each daml {{"x{value}-"}} data (1 2 3)}
      x1-x2-x3-
      
    This one also behaves the same, but the extra quotes slow things down.
      {each daml {"{"x{value}-"}"} data (1 2 3)}
      x1-x2-x3-
      
    These works like you would expect -- each iteration returns an array, which is JSONified internally.
      {each daml "{(:x {string join value {value}} "-")}" data (1 2 3)}
      ["x","1","-"]["x","2","-"]["x","3","-"]
      {each daml {"{(:x {string join value {value}} "-")}"} data (1 2 3)}
      ["x","1","-"]["x","2","-"]["x","3","-"]
    
    These show the strange, sad results of trying to coerce an array into a template.
      {:hey | > :value}
      hey
      {each daml (:x value {value} "{value}" {"{value}"}) data (1 2 3)}
      ["x","hey","hey","hey","hey"]["x","hey","hey","hey","hey"]["x","hey","hey","hey","hey"]
      {each daml (:x {string join value {value}}) data (1 2 3)}
      ["x","hey"]["x","hey"]["x","hey"]
      {each daml {(:x value "-")} data (1 2 3)}
      ["x","hey","-"]["x","hey","-"]["x","hey","-"]

    It pairs nicely with blocks:
      {each daml foo data (1 2 3)}
      x1-x2-x3-
      {foo | each data (1 2 3)}
      x1-x2-x3-
      {begin foo | each data (1 2 3)}x{value}-{end foo}
      x1-x2-x3-
      
      {({:8} {8})}
      ["8",8]
    
  [TODO: upgrade the test suite to allow blocks to spread over lines.]

      {begin foo |}One{"1 2 3" | string split on " "}Two{end foo}
      One["1","2","3"]Two

    These two things are almost equivalent:
      {begin foo | foo}One{"1 2 3" | string split on " "}Two{end foo}
      One["1","2","3"]Two
      {string join value (:One {"1 2 3" | string split on " "} :Two)}
      One["1","2","3"]Two

Snack 3: Aliases

  Many commands have a shorter form that can be used in their place.
    
    Remember our variable setting command?
      {variable set path :bar value (:one :two :three)}
      ["one","two","three"]
    
    These both do the same thing as the preceding command:
      {> :bar value (:one :two :three)}
      ["one","two","three"]
      {(:one :two :three) | > :bar}
      ["one","two","three"]
  
  Aliases work by simple substitution: if the first word of a command matches something in the alias list, it is replaced. (Here "word" is fairly liberal, and includes symbols but not whitespace.)
  
  You can also create aliases at runtime. This is useful when paired with command creation.
    
    Create a new command:
      {daml import template "hey {name}!" into :string as :greet params :name}
        
      {string greet name "yourself"}
        hey yourself!
    
    Alias it:
      {daml alias string "string greet name" as :greet}
        
      {greet "Jacobinius"}
        hey Jacobinius!
      
    // TODO: it looks like this doesn't pop the var context stack like it should...
    
  
  Some basic math commands are published by default. All the default aliases for math commands are two characters, which saves some single characters for more common aliases.

     ---> these don't exist any more: use 'add 1' and 'add -1'
    // Increment:
    //   {math increment value 1}
    //   2
    //   {inc 2}
    //   3
    //   {3 | inc}
    //   4
    // 
    // Decrement:
    //   {math decrement value 257}
    //   256
    //   {dec 256}
    //   255
    //   {255 | dec | dec}
    //   253

  You can find more math commands and their default aliases in the Common Commands section.


:::Quick Notes 2:::

A few small tidbits that don't fit elsewhere.

Quick 1: Comments

    Comments are like this:
      {/string join}

    This works too:
      {/{hey now}}

    You can get fancy:
      {// {hey now} //}

Quick 2: Embedded blocks

    I put a block in a block for you:
      {begin outer |}qq {begin inner | add 321}123{end inner} pp {end outer}
        qq 444 pp

  (Blocks with the same name can't be nested. That would just be weird.)

Quick 3: Commands in lists

    A list can have commands in it
      {({string split value "shantung weft repp slub" on " "} 1 2 4 8)}
        [["shantung","weft","repp","slub"],1,2,4,8]

Quick 4: Quotes in braces

    If the nested quotes are in braces, you don't need to use a block:
      {string split on " " value {("inside" "here") | string join on " "}}
        ["inside","here"]
        
    Sometimes nesting quotes in braces and braces in quotes works well:
      {string split on " " value {"{("Much" "nesting") | string join on " "} is divinest sense" | run}}
        ["Much","nesting","is","divinest","sense"]


:::In Depth:::

We've seen the 5 elements of DAML (three primitive types, commands, and the pipe operator). We've also seen 3 types of sugar that can be applied (variables, blocks, and aliases). Here we'll examine some of those areas in more depth.

Depth 1: Blocks and scope


NOTE: I've changed this so that certain command (each, merge) set a new block context, but regular blocks don't. I'm not sure this is quite right yet... still deliberating. 


  Variables in DAML are *NOT* block-scoped. 

    A variable created in a block goes away when that block ends:
      {begin block}{123 | > :foo}{end block}{foo}
        123
  
    Variables beginning with '@' are global:
      {begin block}{123 | > :@foo}{end block}{@foo}
        123
    
    Blocks create a new variable:
      {begin block}Hey there{end block}{block}
        Hey there
    
//    Nested blocks are only accessible inside their parent block:
//      {begin outer}{begin inner}123{end inner}{end outer}{inner}
        
      
    Use a global if you need access to it later:
      {begin outer}{begin inner | > :@inner}123{end inner}{end outer}{@inner}
        123
    
    Variables created in the outermost scope (outside of any blocks) can be accessed anywhere:
      {123 | > :x ||}{begin foo}{x}{end foo}{x}
      123
    
//    But they aren't actually globals:
//      {123 | > :x ||}{begin foo |}{456 | > :x ||}{x}{end foo}{x}
//      456123
  
  See what happened there? We overwrote the variable in the inner scope, but when the block ended that scope vanished, leaving behind the original variable value.
  
    Contrast that with a global:
      {123 | > :@x ||}{begin foo |}{456 | > :@x ||}{@x}{end foo}{@x}
      456456
  
  Changing a global changes it everywhere, regardless of scope. 
  
  Note: you may have heard tell of evil, unhygienic globals afflicting general purpose programming languages. Fortunately, DAML isn't general purpose. In DAML globals are cute and cuddly and always floss.
  
//    Blocks establish a new variable scope:
//      {"asdf" | > :x}{begin foo}{123 | > :x || x}{end foo}{x}
//  
//    But variables starting with '@' are global:
//      {"asdf" | > :@x}{begin foo}{123 | > :@x || @x}{end foo}{@x}


Depth 2: Maps
  TODO: this whole section needs changing to conform with the new 'list' data type.

  A map (aka hash, dictionary, associative array, key-value store, etc etc etc) is a function that takes keys and returns values. There's no built-in syntax for creating maps, but fortunately we have a command to do it for us.
  
    Here is the command written out:
      {list pair value (:one :first :two :second)}
      {"one":"first","two":"second"}
      
    And in its much more common aliased form:
      {* (:one :first :two :second)}
      {"one":"first","two":"second"}
    
  As you can see, the * operator (which is really just an alias for a command) uses the first value in the list as a key, the second as its value, the third as the second key, the fourth as its value, and so on. While this seems a bit messy on a single line, with proper whitespacing it's very easy to read. 

    In DAML maps are sorted, so we can use the #N notation on them:
      {* (:one :first :two :second) | > :x || x.#2}
      second
    
    [Integer keys in maps can mess up the sorting in the JS implementation]
  
    a list of hashes:
      {( {* (:one 1 :two 2)}  {* (:three 3 :four 4)} )}
        [{"one":1,"two":2},{"three":3,"four":4}]
        
    a nested hash:
      {* (:A {* (:one 1 :two 2)} :B {* (:three 3 :four 4)})}
        {"A":{"one":1,"two":2},"B":{"three":3,"four":4}}
  

Depth 3: Further fun with variables
  
  
  
  .*
  AoH
  #vars

    ALL-CAPS variables are write-once read-many (WORM):
      {128 | > :MY.id}
        128
      {256 | > :MY.id}
        128
      // the above also throws an error...

      Request variables come from POST and the querystring. Reference them like this:
      {REQUEST.foo}

      Or use the short form:
      {#foo}

    Dot values. You can reach inside variables in a variety of ways. Here's a list.

      A named parameter:
        {* (:one 1 :two 2 :three 3) | > :x | x.two}
          2

      A numbered parameter (notice numbering is 1-indexed):
        {x.#1}
          1
        {x.#5}

      You can also go negative:
        {x.#-2}
          2
        
        {x.#-5}

    You can use the magic character ('__') to access the pipe value.

      ex1: single pipe
      ex2: double pipe -- both params
      ex3: param -> pipe scrape

    And back to vars:

      Reaching into a list of hashes brings back an array:
        {( {* (:one 1 :two 2)}  {* (:one 10 :two 20)} ) | __.one}
          [1,10]

      ex: double dipping, like __.companies.employees

      ex: using .*. formation

      ex: using .{}. notation
      {@bundle.{@bar.one}.one | eq :1}

      //
      // test DAML path setting
      //

      {:ash | > :hash.{"two"}} {hash}
        ash {"two":"ash"}

      {:ash | > :hash.{"two"}.monkey.flu} {hash}
        ash {"two":{"monkey":{"flu":"ash"}}}


Depth 4: Creating commands
  
Depth 5: Creating aliases

//    Get all current aliases: 
//      {alias find}
//    
//    Make an alias yourself:
//      {alias add string "string join" as :join}
//
//    This time we'll include the param value. Notice we wrap it in a block first, to handle the nested quotes:
//      {begin j}string join on ", "{end j}{alias add string j as :stick}


:::Bindings and such:::

    {variable bind path :test daml "{count1 | add 1 | > :count1}"}
      
    {:a | > :test}
      a
      
    {count1}
      1
    
  The magic var var __var takes var's val. This allows each binding to reference the value of the variable at the time it was edited, without regard for other bindings.
    {variable bind path :test daml "{count2 | add 1 | > :count2}"}
      
    {:b | > :test}
      b
      
    {count1} x {count2}
      2 x 1
      
    {variable unbind path :test daml "{count1 | add 1 | > :count1}"}
  
    {:c | > :test}
      c
      
    {count1} x {count2}
      2 x 2
    
    {variable bind path :testx.y.z daml "{count2 | add 2 | > :count2}"}
    
    {:x | > :testx.y.z}
      x
    
    {count1} x {count2}
      2 x 4
    
  You can edit the bound var directly in the daml -- infinite recursion is prevented.
    {variable bind path :foox daml "{__var.#1 | add 2 | > :foox.0}"}
    
    {(7 2) | > :foox}
      [7,2]
    
    {foox}
      [9,2]
  
  Multiple bindings can edit the var in different ways (they all receive the original value through __var).
    {variable bind path :foox daml "{__var.#1 | add __var.#2 | > :foox.1}"}

    {(7 2) | > :foox}
      [7,2]
    
    {foox}
      [9,9]
      
  // THINK: make a different test suite for the dom handler and interactive stuff.
  
:::Common Commands:::
  
This section covers a variety of commonly-used commands. 

CC 1: Math commands

  // TODO: move this
  Ensure values are properly finagled. 
    {1 | > :x | 2 | > :y | 3 | > :z | (x y z) | add}
      6
      
      --> these don't exist anymore
   //  Increment:
   //    {math increment value 222}
   //    223
   //    {inc 222}
   //    223
   //    {222 | inc}
   //    223
   // 
   //  Decrement:
   //    {math decrement value 222}
   //    221
   //    {dec 222}
   //    221
   //    {222 | dec}
   //    221
  
    Add:
      {math add value 123 to 321}
        444
      {add 123 to 321}
        444
      {321 | add 123}
        444
  
    The addition command is fairly versatile:
      {math add value (1 2 3)}
        6
      {math add value 1 to (4 5 6)}
        [5,6,7]
      {math add value (4 5 6) to 1}
        [5,6,7]
      {math add value (3 2 1) to (4 5 6)}
        [7,7,7]
      
    Subtract
      {subtract 4 from :7}
        3
      {:7 | subtract 4}
        3
      {subtract (:100 :2 3 :4 5)}
        86
      {(1 3 5 7) | subtract 3}
        [-2,0,2,4]
      {math subtract value (6 5 4) from (1 2 3)}
        [-5,-3,-1]
      
    Multiply
      {multiply 4 by 7}
        28
      {:7 | multiply :4}
        28
      {multiply (:1 2 :3)}
        6
      {(1 :2 3) | multiply 3}
        [3,6,9]
      {math multiply value (1 2 3) by (6 5 4)}
        [6,10,12]
      
    Divide // NOTE that this shortcut is different!
      {divide value 7 by 4}
        1.75
      {:7 | divide by :4}
        1.75
      {divide value (:1 2 :3) | map daml "{value | round to 2}"}
        ["0.17"]
      {(1 2 3) | divide by 3 | map daml "{value | round to 2}"}
        ["0.33","0.67","1"]
      {math divide value (1 2 3) by (6 5 4) | map daml "{value | round to 2}"}
        ["0.17","0.4","0.75"]
      
      // THINK: it's a little weird that the above return as strings. consider allowing the outputter to release numbers.
      
      
    Mod
      {math mod value 7 by 2}
        1
      {:7 | mod :2}
        1
      
    Pow
      {math pow value 2 exp 8}
        256
      {:5 | math pow exp :3}
        125
      {5 | math pow exp 0.5}
        2.23606797749979
    
    Less? // THINK: should less be logic?
    Random?
    
    Round
      {123.456 | math round}
        123
      {123.456 | math round to -2}
        100
      {123.456 | math round to 2}
        123.46
        
  
  
CC 2: Looping
  
  There are two primary loop commands in DAML: each and merge. They require a string (the template) and a list or map (the data). Both work by variablizing each element of data in turn and running the template over it.
  
    Foreach pushes each element into a variable called 'value':
      {each data (1 2 3) daml "{value}x"}
      1x2x3x
    
    The each command also pushes the value's key into a variable called 'key':
      {each data {* (:one 1 :two 2 :three 3)} daml "{key}x"}
      onextwoxthreex
    
    It works on blocks, too, naturally. Here we use the common alias form:
      {begin loop | each data {* (:one 1 :two 2 :three 3)}} {key}: {value} {end loop}
      one: 1  two: 2  three: 3
  
  Merge is a little more complicated
  
  
  A 'each' will take each element of a list or map and push it into a variable called 'value'
  A 'merge' will push
  
  merging...
  {(@bar @hash) | > :bundle}
  {begin block | merge with @bundle} {one} {end block}
  
  
  
  
  
  
  
  
  
  
  
  // next up: coffee, jazz, obscure sports, obscure holidays, autological (anti, homo, etc), deep sea creatures, church/kleene/turing etc, russell/conway/tarski etc, singularity/bingularity/tringularity, murray gell-mann, pynchon&co, funny parts of the eye, shakespearean neologisms, joycean neologisms, other biology, music theory, strange foods, topological space organization (T1), the lambda cube, ways of making numbers, mermaid > duck > bunny > manatee, 
  


{(:One {"1 2 3" | string split on " "} :Two)}
  ["One",["1","2","3"],"Two"]

{begin foo | foo}One{"1 2 3" | string split on " "}Two{end foo}
  One["1","2","3"]Two

{begin foo}One{"1 2 3" | string split on " "}Two{end foo}{foo}
  One["1","2","3"]Two


{"{:asdf}"} bax
  asdf bax

{"{:asdf}" | quote} bax
  {:asdf} bax

{"{"{:asdf}"} bax"}
  asdf bax

{"{"{:asdf}"} bax" | quote}
  {"{:asdf}"} bax

{"{"{:asdf}" | quote} bax"}
  {:asdf} bax

{"{"{:asdf}"} bax" | quote | unquote}
  asdf bax

{(1 {:asdf} 3)}
  [1,"asdf",3]

{(1 {"{:asdf}"} 3)}
  [1,"asdf",3]

{(1 "{:asdf}" 3)}
  [1,"asdf",3]

{(1 {:asdf | string split} 3)}
  [1,["asdf"],3]

{(1 "{:asdf | string split}" 3)} {// this becomes a string of an array of a string because of the quotes //}
  [1,"[\"asdf\"]",3]

{(1 {"{:asdf | string split}"} 3)}
  [1,"[\"asdf\"]",3]

{"{(1 "{:asdf | string split}" 3)} bax"}
  [1,"[\"asdf\"]",3] bax


Tests for command + string
{foo asdf} bax
 bax
 
{string split value "foo bat" on " "} baz
["foo","bat"] baz

Regex for grep:
{string grep value (:hello :world) on "/.llo/"}
["hello"]

Basic blocks and vars:
{begin foo | string split on " " | grep :h}hello how are you?{end foo}
["hello","how"]

{begin foo | ""}hello{end foo}{foo | grep :llo}
["hello"]

{> :x value (:foo :buzz :bizz :bazz) | grep :zz value x}
["buzz","bizz","bazz"]

{begin foo | string split on " " | > :x ||}hello hey zebra squid{end foo}{x | grep :h}
["hello","hey"]



// this is a pipe

// ceci n'est pas une pipe


// A STRANGE THING

  This obviously does what you would expect, processing the list elements in order:
  // NOTE: false -> "" when output as a string, but not when JSONified.
    {( a {2 | > :a} a )}
      [false,2,2]

  Same:
    {( {a} {4 | > :a} {a} )}
      [2,4,4]

  This also does what you'd want:
    {( "{a}" {8 | > :a} {a} )}
      ["4",8,8]

  This, however, is a little different. 
    {( "{a}" {16 | > :a} {a} ) | __}
      ["8",16,16]
    {( "{a}" {32 | > :a} {a} ) | __}
      ["16",32,32]
    
  That's probably a bug. it really shouldn't be ["8",32,32]...
  // TODO: remove above; this is fixed now.
  
// STRINGS

  -- internal strings containing DAML are considered 'alive'. among other things, this means that they will eventually be processed.
  -- data coming from outside the processed string (db, user, etc) is 'dead'. dead string won't be processed.
  -- strings w/o DAML are dead.
  -- the 'quote' command kills a live string.
  -- the 'unquote' command resuscitates a dead string.
  -- you can put a live string in a variable, and reference it many different times. each will be processed according to the customs of its time.
  -- the 'run' command fully processes (and kills) a live string.
  -- string transformation commands (of any kind) kill live strings.
  

// BASIC SYNTAX


// various null-value checks
{}

{{}}

{|}

{||}

{ }

{abra}

{""}



// comments and brace matching
{/a}y
y
{/a {b} c}y
y
{/a {b{c}d} e}y
y
{/a {b} {c} d}y
y
{/a {b{c}d} {e} f}y
y

// / comments and escaped braces
// {/a \} b}y
// y

{ /a \openbracegoeshere b}y
  y

{/a \{\} b}y
  y

// \{alpha\}y
// {alpha}y

// tests for quote and brace matching

{* ("one" "local" "two" "surprise local!" "foo" "bar" "bar" "{foo}") | > :x}
  {"one":"local","two":"surprise local!","foo":"bar","bar":"hello hey zebra squid"}

{{"stupid"}} y
  stupid y
{"stupid {x.one}"} y
  stupid local y
{"{"stupid"} {x.one}"} y
  stupid local y
{"{"stupid {x.one}"} {x.one}"} y
  stupid local local y
{"{"stupid {"{x.one}"}"} {x.one}"} y
  stupid local local y
{"{"stupid {"{x.one} {x.two}"}"} {x.one}"} y
  stupid local surprise local! local y
{"{"stupid {"{x.one} {x.two} {x.bogus.foo}"}"} {x.one}"} y
  stupid local surprise local!  local y



// array commands

$GLOBALS['X']['VARS']['STATIC']['data'] = 
  array(
        '2' => array('one' => 'second', 'two' => array('hinterlands', 'yellow', 'mishmash'), 'three' => 'odd'),
        '1' => array('one' => 'first', 'two' => array('hi', 'hello', 'hijinx', 'goodbye'), 'three' => 'even'),
        '3' => array('one' => 'third', 'two' => array('hinterlands', 'yellow', 'mishmash'), 'three' => 'even'));


// // list commands
// {@data | list count}
// 3
// 
// {((:one :row) (:second :row)) | list to_csv}
// one,row\nsecond,row
// 
// {((:one :row) (:second :row)) | list to_json}
// [["one","row"],["second","row"]]
// 
// // otherwise the {...} gets proc'd
// {{* (:one :row :second :row)} | list to_json | quote}
// {"one":"row","second":"row"}
// 
// // intersection
// {list intersect values (@data.1.two (:hi :hello :gogo))}
// ["hi","hello"]
// 
// {list intersect values (@data.1 {* (:one :first :four :nothing)})}
// {"one":"first"}
// 
// // keys
// {@data | list keys}
// [2,1,3]
// 
// // organize
// {@data | list organize command "sort:one,desc;"}
// {"1":{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},"2":{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"},"3":{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}}
// 
// {@data | list organize command "stack:three;"}
// {"odd":{"count":1,"column":"three","value":"odd","items":[{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"}]},"even":{"count":2,"column":"three","value":"even","items":[{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]}}
// 
// {@data | list organize command "sort:one,desc;stack:three;"}
// {"even":{"count":2,"column":"three","value":"even","items":[{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]},"odd":{"count":1,"column":"three","value":"odd","items":[{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"}]}}
// 
// // rekey
// {@data | list rekey key_by :one}
// {"second":[{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"}],"first":[{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"}],"third":[{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]}
// 
// {@data | list rekey key_by :three}
// {"odd":[{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"}],"even":[{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]}
// 
// // remove
// {@data | list remove path :2}
// {"1":{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},"3":{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}}
// 
// {@data | list remove path "*.two"}
// {"1":{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},"3":{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}}
// 
// {(:one :two :three) | list remove path :one}
// ["two","three"] 
// 
// // union
// {list union value (@data (:1 :2 :four))}
// [{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"},{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"},"1","2","four"]
// 
// {list union value (@data {*(:1 {* (:one :lovely :four :goodness)})})}
// [{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"},{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]
// 
// // unique
// {(:hi :hi :puffy :ami :yumi) | list unique}
// {"0":"hi","2":"puffy","3":"ami","4":"yumi"}
// 
// // prune
// {list prune value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {this | less than :4} path "*.*"}
// [{"one":{"2":"5"},"two":{"2":"4"}},{"one":{"1":"4","2":"5"},"two":{"2":"4"}}]
// 
// {list prune value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {parent.parent.one.1 | is like :3} path "*.*"}
// [{"one":[],"two":[]},{"one":["3","4","5"],"two":["1","3","4"]}]
// 
// // extract
// {list extract value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {this | less than :4} path "*.*"}
// ["2","3","1","3","3","1","3"]
// 
// {list extract value ({* (:one (:2 :3 :5) :two (:1 :3 :4))} {* (:one (:3 :4 :5) :two (:1 :3 :4))}) expression {parent.parent.one.1 | is like :3} path "*.one"}
// ["2","3","5"]
// 
// // sort
// {@data | list sort by :one}
// [{"one":"first","two":["hi","hello","hijinx","goodbye"],"three":"even"},{"one":"second","two":["hinterlands","yellow","mishmash"],"three":"odd"},{"one":"third","two":["hinterlands","yellow","mishmash"],"three":"even"}]
// 
// {@data | list sort by {* (:three :desc :one :asc)} | __.one}
// ["second","first","third"]
// 
// {@data | list sort by {* (:three :desc :one :desc)} | __.one}
// ["second","third","first"]
// 
// {@data | list sort by {* (:two.#2 :desc :one :desc)} | __.one}
// ["third","second","first"]
// 
// {@data | list sort by {* (:two.#2 :desc :one :asc)} | __.one}
// ["second","third","first"]


// LOGIC


$GLOBALS['X']['VARS']['LOCAL'] = array('one' => 'local', 'two' => 'surprise local!', 'foo' => 'bar', 'bar' => '{foo}
$GLOBALS['X']['VARS']['BLOCK'] = array('one' => 'string', 'two' => 'surprise string!', 'temp' => "{one} and {two} ");
$GLOBALS['X']['VARS']['STATIC']['data'] = array(array('one' => 'array', 'two' => 'surprise array!'),array('one' => 'second', 'two' => 'surprise number also!'));
$GLOBALS['X']['VARS']['STATIC']['hash'] = array('one' => 'hashly', 'two' => 'bashly', 'three' => 'crashly


// logic commands
  ~~~ OR returns the first true value it finds ~~~
  
  One valued 'or' looks at each item in the list
    {(false 1 2 3) | or}
      1

    {or (false 1 2 3)}
      1

    {or (false 0 "" :true)}
      true

  With two values it just considers each in toto
    {5 | or 10}
      5
  
    {false | or :true}
      true

    {(0 0) | or 1}
      [0,0]

    {false | or (0 0)}
      [0,0]

  ~~~ AND only returns true or false ~~~

  One valued 'and' looks at each item in the list
    {(false 1 2 3) | and | then :true else :false}
      false
      
    {and (false 1 2 3) | then :true else :false}
      false
      
    {and (false 0 "" :true) | then :true else :false}
      false
      
    {(1 2 3) | and | then :true else :false}
      true

    // NOTE: the below fail due to faulty piping that sets 'also' to 'false'. 

    {and (1 2 3) | then :true else :false}
      true

    {and ("asdf" :true) | then :true else :false}
      true

  With two values it just considers each in toto
    {5 | and 10 | then :true else :false}
      true
  
    {false | and :true | then :true else :false}
      false

    {(0 0) | and 10 | then :true else :false}
      true

    {false | and (0 0) | then :true else :false}
      false

{if :true then :awesome}
  awesome

{if "" then "not awesome"}
  
{if false then "not awesome"}
  
{if {not ""} then :awesome}
  awesome

{if {and ({not ""} {not false})} then :awesome}
  awesome

{if {and ({or ({not false} false)} x)} then :awesome}
  awesome

{if {and ({false} {x})} then :awesome}

{if {and (:great "not bad!")} then :awesome}
  awesome

{if {and (:great "not bad!" nothing)} then "bad" else :awesome}
  awesome

{:true | if __ then :neat}
  neat

{:true | else "bad"}
  true

{false | else "good"}
  good

{:asdf | is in (:foo :bar :asdf) | then :great}
  great

{:asdf | is in (:foo :bar) | then "bad" else :great}
  great

{:burgers | eq "urge" | then "uh-oh" else :super}
  super

{:burgers | is like "/urge/" | then :super else "uh-oh"}
  super

{:burgers | is like "/URGE/i" | then :super else "uh-oh"}
  super

{:burgers | is like "/URGE/" | then "oh no!" else :super}
  super

{:burgers | is like "/^urge/" | then "oh no!" else :super}
  super

{false | not | then :true else :false}
  true

{:true | not | then :true else :false}
  false

{not false | then :true else :false}
  true

{not :true | then :true else :false}
  false

{cond (false "bad!" {:true} "{:yep}" nope "baaaad!!!")}
  yep

{cond ((false "bad!") ({:true} 456 "hey {bat}") ({123 | > :bat} "too far"))}
  hey


// PARAMS


$GLOBALS['X']['VARS']['BLOCK'] = array('one' => 'one', 'two' => 'surprise string!', 'temp' => "{one} and {two} ");

$GLOBALS['X']['VARS']['STATIC']['hash'] = $hash = array('one' => 'hashly', 'two' => 'bashly', 'three' => 'crashly

$GLOBALS['X']['VARS']['LOCAL'] = $locals = array('one' => 'local', 'two' => 'surprise local!', 'foo' => 'bar', 'bar' => '{foo}', 'hash' => $hash);

$GLOBALS['X']['VARS']['STATIC']['data'] = array(
  array('one' => 'first', 'two' => 'surprise array!', 'locals' => $locals),
  array('one' => 'second', 'two' => 'surprise number also!', 'locals' => $locals),
  array('one' => 'third', 'two' => 'surprise me too!', 'locals' => $locals));


{* (:one :one :two :two :three :three) | > :numbers ||}

{* (:one :hashly :two :bashly :three :crashly) | > :@hash ||}

{* (:one :local :two "surprise local!" :foo :bar :bar foo :hash @hash) | > :locals ||}

{( {* (:one :first :two "surprise array!" :locals locals)} {* (:one :second :two "surprise number also!" :locals locals)} {* (:one :third :two "surprise me too!" :locals locals)} ) | > :@data ||}


{@hash.one}
hashly
                 
// replacement with command parsing
{@data.{"1"}.one}
second

{@data.{1}.{numbers.one}}
second

// careful with numerical tests!
{@data.1.one}
second

{@data.#1.one}
first

{@data.#-1.one}
third

{@data.#12.one}

{@data.#-33.one}

// check iteration
{@data.one}
["first","second","third"]

{@data.locals.hash.one}
["hashly","hashly","hashly"]

{@data.locals.foo}
["bar","bar","bar"]

// // check stars
// {@data | array count}
// 3
// 
// {@data.* | array count}
// 9
// 
// {@data.*.* | array count}
// 15
// 
// {@data.*.*.* | array count}
// 9
// 
// {@data.*.*.*.*}
// 
// {@data.*.one}
// first
// 
// {@data.*.*.one}
// local
// 
// {@data.*.*.*.one}
// hashly

// {@data.foo.*}

{@data.one.foo}

{@data.one.#1.foo}



//
// now with more tests!
//

$a_john = array('name' => 'Awesome John', 'age' => 'alpha
$a_bobs = array('name' => 'Awesome Bobs', 'age' => 'beta
$a_mary = array('name' => 'Awesome Mary', 'age' => 'gamma
$a_stev = array('name' => 'Awesome Stev', 'age' => 'delta

$awesome_people = array($a_john, $a_bobs, $a_mary, $a_stev);

$c_john = array('name' => 'Cool John', 'age' => 'alpha
$c_bobs = array('name' => 'Cool Bobs', 'age' => 'beta
$c_mary = array('name' => 'Cool Mary', 'age' => 'gamma
$c_stev = array('name' => 'Cool Stev', 'age' => 'delta

$cool_people = array($c_john, $c_bobs, $c_mary, $c_stev);

$n_john = array('name' => 'Neat John', 'age' => 'alpha
$n_bobs = array('name' => 'Neat Bobs', 'age' => 'beta
$n_mary = array('name' => 'Neat Mary', 'age' => 'gamma
$n_stev = array('name' => 'Neat Stev', 'age' => 'delta

$neat_people = array($n_john, $n_bobs, $n_mary, $n_stev);

$GLOBALS['X']['VARS']['STATIC']['companies'] = array(
  array('name' => 'awesome test co', 'employees' => $awesome_people, 'boss' => $a_john),
  array('name' => 'cool test co', 'employees' => $cool_people, 'boss' => $c_john),
  array('name' => 'neat test co', 'employees' => $neat_people, 'boss' => $n_john));

/* 
  write tests:
  - find by number then name (companies.#-2.boss.name)
  - find by range (companies.employees) [all employees]
  - find by range-and-key (companies.employees.name) [all employee names]
  - find by range-and-key-and-number (companies.employees.#2.name) [name of second employee at each company? nope, it's the second employee overall]
*/

// {@companies.#-2.boss.name}
// Cool John
// 
// {@companies.employees}
// [{"name":"Awesome John","age":"alpha"},{"name":"Awesome Bobs","age":"beta"},{"name":"Awesome Mary","age":"gamma"},{"name":"Awesome Stev","age":"delta"},{"name":"Cool John","age":"alpha"},{"name":"Cool Bobs","age":"beta"},{"name":"Cool Mary","age":"gamma"},{"name":"Cool Stev","age":"delta"},{"name":"Neat John","age":"alpha"},{"name":"Neat Bobs","age":"beta"},{"name":"Neat Mary","age":"gamma"},{"name":"Neat Stev","age":"delta"}]
// 
// {@companies.employees.name}
// ["Awesome John","Awesome Bobs","Awesome Mary","Awesome Stev","Cool John","Cool Bobs","Cool Mary","Cool Stev","Neat John","Neat Bobs","Neat Mary","Neat Stev"]
// 
// {@companies.employees.#2.name}
// Awesome Bobs






//
// a couple more for the road
//

$GLOBALS['X']['VARS']['STATIC']['test_notices'] = array("row_inserted" => array("20" => "Row updated"));

// {@test_notices.row_inserted.1}
//   
// {@test_notices.row_inserted.20}
// Row updated
//   
// {string lowercase value {"{@MY.keychain.#1}/asdf"}}
// __world/asdf
  
// PROCESS


$GLOBALS['X']['VARS']['LOCAL'] = array('one' => 'local', 'two' => 'surprise local!', 'foo' => 'bar', 'bar' => '{foo}
$GLOBALS['X']['VARS']['BLOCK'] = array('one' => 'string', 'two' => 'surprise string!', 'temp' => "{one} and {two} ");
$GLOBALS['X']['VARS']['STATIC']['data'] = array(array('one' => 'array', 'two' => 'surprise array!'),array('one' => 'second', 'two' => 'surprise number also!'));
$GLOBALS['X']['VARS']['STATIC']['hash'] = array('one' => 'hashly', 'two' => 'bashly', 'three' => 'crashly

$GLOBALS['X']['VARS']['BLOCK']['jdata'] = '[{"id":"298","keyword":"bar"},{"id":"297","keyword":"foo"}]';
$GLOBALS['X']['VARS']['BLOCK']['jtemp'] = '{id} and {keyword} ';


// pipe replacement / merge commands
$TESTS[1] = array('in' => '{"{one} and {two} and {three}" | each data @hash}
hashly and surprise local! and local and bashly and local and surprise local! and crashly

// {"{key} and {value}; " | each data @hash as "value" and "key"}
// one and hashly; two and bashly; three and crashly; 
// 
// {"{temp} and {three}" | sub with $temp as :temp | each data @hash}
// hashly and surprise local!  and local and bashly  and local and surprise local!  and crashly
// 
// 
// // blocks with merge and sub
// x{begin anon | merge with @data}{one} and {two}{end anon}
// yxarray and surprise array!second and surprise number also!y
// 
// x{begin anon | sub with @hash}{one} and {two}{end anon}
// yxhashly and bashlyy
// 
// 
// // shortcut replacement
// {merge string $temp with @data}
// array and surprise array! second and surprise number also! 
// 
// 
// // merge with | value
// {$jdata | array from_json | merge string $jtemp}
// 298 and bar 297 and foo 
// 
// {$jdata | array from_json | merge string "{$jtemp}"}
// 298 and bar 297 and foo 
// 
// // merge with {} data
// {merge string $jtemp with {array from_json value $jdata}}
// 298 and bar 297 and foo 
// 
// {$jtemp | merge with {$jdata | array from_json}}
// 298 and bar 297 and foo 
// 
// // merge with sub'd data
// {begin block | sub with $jtemp as :temp | merge with {$jdata | array from_json}}{temp}{end block}
// 298 and bar 297 and foo 
// 
// // merge with 'as' param
// {merge string "{namesake.id} and {namesake.keyword} " with {$jdata | array from_json} as "namesake"}
// 298 and bar 297 and foo 
// 
// {begin block | merge with {$jdata | array from_json} as "namesake"}{namesake.id} and {namesake.keyword} {end block}
// 298 and bar 297 and foo 
// 
// // sub with string
// {sub with $two as :test string "{test}"}
// surprise string!
// 
// // complex sub with string
// {"{temp} and {three}" | sub with $temp as :temp}
// local and surprise local!  and 
// 
// // sub with array
// {sub string "x {test} x" with (:neat :cool) as :test}
// x neat xx cool x
// 
// // sub with array and glue
// {sub string "{test}" with (:neat :cool) as :test glue " x "}
// neat x cool
// 
// // sub with AoH
// {$jdata | array from_json | sub string "{id}:{keyword} "}
// 298:bar 297:foo 
// 
// // sub with AoH and as and glue
// {$jdata | array from_json | sub string "{pico.id}:{pico.keyword}" as :pico glue " x "}
// 298:bar x 297:foo
// 
// // sub with hash
// {sub string "{one} x {two}" with @hash}
// hashly x bashly
// 
// // sub with hash and as
// {sub string "{peg.one} x {peg.two}" with @hash as "peg"}
// hashly x bashly
// 
// // each with 'as' param
// {each daml "{one} {two} x " data @hash}
// hashly surprise local! x local bashly x local surprise local! x 
// 
// // each with 'as' param
// {each daml "{peg} x " data @hash as "peg"}
// hashly x bashly x crashly x 



// DAML commands...


// STRING commands...

